{"version":3,"file":"parseCell.js","names":["_parseCellValue","_interopRequireDefault","require","_coordinates","_xlsx","_dom","obj","__esModule","parseCell","node","sheet","xml","values","styles","properties","options","coords","parseCellCoordinates","getAttribute","valueElement","getCellValue","value","textContent","type","hasAttribute","row","column","parseCellValue","getInlineStringValue","getCellInlineStringValue","getInlineStringXml","getOuterXml","getStyleId"],"sources":["../../source/read/parseCell.js"],"sourcesContent":["import parseCellValue from './parseCellValue.js'\r\n\r\nimport {\r\n  parseCellCoordinates\r\n} from './coordinates.js'\r\n\r\nimport {\r\n  getCellValue,\r\n  getCellInlineStringValue\r\n} from '../xml/xlsx.js'\r\n\r\nimport {\r\n  getOuterXml\r\n} from '../xml/dom.js'\r\n\r\n// Example of a `<c/>`ell element:\r\n//\r\n// <c>\r\n//    <f>string</f> — formula.\r\n//    <v>string</v> — formula pre-computed value.\r\n//    <is>\r\n//       <t>string</t> — an `inlineStr` string (rather than a \"common string\" from a dictionary).\r\n//       <r>\r\n//          <rPr>\r\n//            ...\r\n//          </rPr>\r\n//          <t>string</t>\r\n//       </r>\r\n//       <rPh sb=\"1\" eb=\"1\">\r\n//          <t>string</t>\r\n//       </rPh>\r\n//       <phoneticPr fontId=\"1\"/>\r\n//    </is>\r\n//    <extLst>\r\n//       <ext>\r\n//          <!--any element-->\r\n//       </ext>\r\n//    </extLst>\r\n// </c>\r\n//\r\nexport default function parseCell(node, sheet, xml, values, styles, properties, options) {\r\n  const coords = parseCellCoordinates(node.getAttribute('r'))\r\n\r\n  const valueElement = getCellValue(sheet, node)\r\n\r\n  // For `xpath`, `value` can be `undefined` while for native `DOMParser` it's `null`.\r\n  // So using `value && ...` instead of `if (value !== undefined) { ... }` here\r\n  // for uniform compatibility with both `xpath` and native `DOMParser`.\r\n  let value = valueElement && valueElement.textContent\r\n\r\n  let type\r\n  if (node.hasAttribute('t')) {\r\n    type = node.getAttribute('t')\r\n  }\r\n\r\n  return {\r\n    row: coords[0],\r\n    column: coords[1],\r\n    value: parseCellValue(value, type, {\r\n      getInlineStringValue: () => getCellInlineStringValue(sheet, node),\r\n      getInlineStringXml: () => getOuterXml(node),\r\n      getStyleId: () => node.getAttribute('s'),\r\n      styles,\r\n      values,\r\n      properties,\r\n      options\r\n    })\r\n  }\r\n}"],"mappings":";;;;;;AAAA,IAAAA,eAAA,GAAAC,sBAAA,CAAAC,OAAA;AAEA,IAAAC,YAAA,GAAAD,OAAA;AAIA,IAAAE,KAAA,GAAAF,OAAA;AAKA,IAAAG,IAAA,GAAAH,OAAA;AAEsB,SAAAD,uBAAAK,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,gBAAAA,GAAA;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASE,SAASA,CAACC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEC,MAAM,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;EACvF,IAAMC,MAAM,GAAG,IAAAC,iCAAoB,EAACR,IAAI,CAACS,YAAY,CAAC,GAAG,CAAC,CAAC;EAE3D,IAAMC,YAAY,GAAG,IAAAC,kBAAY,EAACV,KAAK,EAAED,IAAI,CAAC;;EAE9C;EACA;EACA;EACA,IAAIY,KAAK,GAAGF,YAAY,IAAIA,YAAY,CAACG,WAAW;EAEpD,IAAIC,IAAI;EACR,IAAId,IAAI,CAACe,YAAY,CAAC,GAAG,CAAC,EAAE;IAC1BD,IAAI,GAAGd,IAAI,CAACS,YAAY,CAAC,GAAG,CAAC;EAC/B;EAEA,OAAO;IACLO,GAAG,EAAET,MAAM,CAAC,CAAC,CAAC;IACdU,MAAM,EAAEV,MAAM,CAAC,CAAC,CAAC;IACjBK,KAAK,EAAE,IAAAM,0BAAc,EAACN,KAAK,EAAEE,IAAI,EAAE;MACjCK,oBAAoB,EAAE,SAAAA,qBAAA;QAAA,OAAM,IAAAC,8BAAwB,EAACnB,KAAK,EAAED,IAAI,CAAC;MAAA;MACjEqB,kBAAkB,EAAE,SAAAA,mBAAA;QAAA,OAAM,IAAAC,gBAAW,EAACtB,IAAI,CAAC;MAAA;MAC3CuB,UAAU,EAAE,SAAAA,WAAA;QAAA,OAAMvB,IAAI,CAACS,YAAY,CAAC,GAAG,CAAC;MAAA;MACxCL,MAAM,EAANA,MAAM;MACND,MAAM,EAANA,MAAM;MACNE,UAAU,EAAVA,UAAU;MACVC,OAAO,EAAPA;IACF,CAAC;EACH,CAAC;AACH"}